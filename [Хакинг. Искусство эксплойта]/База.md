# BASE





## Базовые регистры (x86)

Если что они есть в эссенции

| Название                       | Суть                                                         |
| :----------------------------- | ------------------------------------------------------------ |
| **Временные переменные**       | *=====================================================================* |
| **eax**                        | аккумулятор                                                  |
| **ecx**                        | счетчик                                                      |
| **edx**                        | данных                                                       |
| **ebx**                        | база                                                         |
| **Регистры общего назначения** | *=====================================================================* |
| **esp**                        | указатель стека                                              |
| **ebp**                        | указатель базы                                               |
| **esi**                        | индекс источника                                             |
| **edi**                        | индекс приемника                                             |
| **Особые**                     | *=====================================================================* |
| **eip**                        | указатель инструкции                                         |
| **eflags** (pf sf if)          | флаги для сравнений и адресации                              |

Дальше больше

---

#### ESP / EBP

В общем эти парни, я повторюсь, являются УКАЗАТЕЛЯМИ.

А значит если есть команда **mov**, то примитивный **eax** будет записан в нее без прелюдий, а наши благородные **esp / ebp** потребуют особый подход в виде синтаксиса **"DWORD PTR [esp]"** когда указатель на месте приемника и просто **"[esp]"**, когда указатель на месте источника.







## Базовые команды

Первый вариант оформления

```assembly
mov ebp, esp #перемещает из esp в ebp
sub esp, 0x8 #вычитает из esp 8 и записывает результат в esp

cmp DWORD PTR [ebp-4], 0x9 #cmp сравнивает, DWORD - четыре байта
jle 8048393 <main+0x1f> #jump if less or equal to
jmp 80483a6 <main+0x32> #безусловный jump

lea eax, [ebp-4] #загружает в eax адрес из [ebp-4]
inc DWORD PTR [eax] #переходит по адресу eax и увеличивает значение на 1

mov DWORD PTR [esp], 0x8048484
call 0x80482a0 <printf@plt>
```



Описание команд дальше

----

#### JLE [dst]

*Jump if less or equal to*

Как было сказано ранее данная команда выполняет прыжок в зависимости от результата **cmp**, ну или если какие-то там флаги поменять.

Под капотом перескок осуществляется буквальным изменением регистра **eip**. 

Если же **cmp** не сработал в сторону меньше или равно инструкция **jle** просто пропускается.

Используется в примитивных **if** и **for**.



#### LEA [dst], [src]

*load effective address*

Записывает в dst буквально адрес src. В отличии от mov, записывающей значение из src. 

Объясняю на примере. 

```assembly
# $ebp-4 = 0xbffff804
# [0xbfff804] → 0x00000000
lea eax, [ebp-4] #в eax запишется 0xbffff804
mov eax, [ebp-4] #в eax запишется 0x00000000 (все из-за квадратных скобок - см Базу)
```

По идее **"lea eax, [ebp-4]"** это то же самое, что если бы мы **"mov eax, ebp-4" ** – без скобок, заметь, но я не уверен, что так можно.



#### INC [dst]

increment, obviously

```assembly
# $eax = 0xbffff804
# [0xbfff804] → 0x00000000
inc DWORD PTR [eax]
# $eax = 0xbffff804
# [0xbfff804] → 0x00000001
```

В данном случае увеличился не сам eax, а значение, на которое он указывал (из-за скобок)



#### PRINTF (call 0x80482a0)

Принтит. 

```assembly

mov DWORD PTR [esp], 0x8048484
# $esp = 0xbffff800
# [0xbffff800] → 0x8048484
# [0x8048484] → 0x6c6c6548 = 0x48(H) 0x65(e) 0x6c(l) 0x6c(l)
# [0x8048485] → 0x6f57206f = 0x6f(o) 0x20(SPACE) 0x57(W) 0x6f(o)
# то есть Hello world
call 0x80482a0 <printf@plt>
```

