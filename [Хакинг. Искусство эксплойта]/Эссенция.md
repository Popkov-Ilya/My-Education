# Хакинг. Искусство эксплойта (Джон Эриксон)

Книга читается – хакинг изучается



### Начнем с малого

```bash
gcc firstprog.c # скомпилировать c-код в исполняемый файл a.out
gcc -o programm_name firstprog.c # скомпилировать c-код в исполняемый файл programm_name
ls -lh a.out
./a.out
```



##### Расширяем горизонты

```bash
# посмотреть дизассемблированный код a.out
objdump -D a.out | grep -A20 main.:

# посмотреть дизассемблированный код a.out в синтаксисе интел
objdump -M intel -D a.out | grep -A20 main.:
```



##### Работаем с отладчиком

```bash
gdb -q a.out
# дальше все что начинается с (gdb) происходит внутри отладчика
(gdb) break main # поставить точку останова на функции main
# (gdb) break 6 - поставить точку останова на 6 строке
(gdb) run # запустить прогу
(gdb) info registers # посмотреть состояние регистров до запуска мейна
(gdb) quit # выйти из отладчика
```



##### И вот они регистры x86 слева направо

| Название                       | Суть                                                         |
| :----------------------------- | ------------------------------------------------------------ |
| **Временные переменные**       | *=====================================================================* |
| **eax**                        | аккумулятор                                                  |
| **ecx**                        | счетчик                                                      |
| **edx**                        | данных                                                       |
| **ebx**                        | база                                                         |
| **Регистры общего назначения** | *=====================================================================* |
| **esp**                        | указатель стека                                              |
| **ebp**                        | указатель базы                                               |
| **esi**                        | индекс источника                                             |
| **edi**                        | индекс приемника                                             |
| **Особые**                     | *=====================================================================* |
| **eip**                        | указатель инструкции                                         |
| **eflags** (pf sf if)          | флаги для сравнений и адресации                              |



##### Настраиваем отладчик под Интел архитектуру

```bash
gdb -q
(gbd) set disassembly intel
(gdb) quit

echo "set dis intel" > ~/.gdbinit # 1) команды gdb можно сокращать 2) настройки нужно сохранить для перезапусков
```



##### Еще синтаксис компилятора и отладчика

```bash
gcc -g firstprog.c # добавляет в программу данные о коде
gdb -q a.out
(gdb) list # выведет c-код программы
(gdb) disassemble main # вывести дизассемблированный мейн (disass main)
(gdb) break main # поставить как обычно точку останова
(gdb) run # запустить прогу (теперь отладчик знает на какой строке c-кода он остановился)
(gdb) info register eip # (i r eip, если кратко) посмотреть что находится в регистре указателя инструкции
```



##### Исследование памяти

Для изучения памяти используется команда **examine** (кратко - **x**). 

Цифрой обозначается количество блоков для вывода.

Способы вывода блоков:

1) o – в виде восьмеричного числа
2) x – в виде шестнадцатеричного числа
3) u – в виде целого десятеричного числа без знака
4) d – в виде двоичного числа

Размер выводимого блока регулируется второй буквой (*помни про little-endian*)

1. b – байт
2. h – полуслово (2 байта) [ слово в ассемблере ]
3. w – слово (4 байта) [ DWORD в ассемблере ] **default**
4. g – гига-слово (8 байт)

```bash
(gdb) x/x 0x8048384 # вывести 4 байта ячейки 0x8048384 в шестнадцатиричном формате
(gdb) x/4ug 0x8048384 # вывести 4 раза по 8 байтов начиная с ячейки 0x8048384
(gdb) print $ebp - 4 # созранит в переменной $1 свое значение для дальнейшего использования
(gdb) x/dw $1 # вывести 4 байта в двоичном коде из ячейки (ebp-4) 
```

Особые случаи

1. i – вывести инструкцию из данной ячейки.
2. c – вывести при возможности ASCII символы
3. s – не заморачиваясь вывести просто ASCII строку, записанную начиная с заданной ячейки до ближайшего 0

```bash
(gdb) x/i 0x8048394 # инструкция по адресу
(gdb) x/6cb 0x8048484 # 12 символов по байтно (если не символ - вернет значение)
(gdb) x/s 0x8048484 # без изысков - просто выведет строку "Hello world!\n" например
```



##### Инструкции

В GDB можно по порядку выполнять инструкции при этом еще и отображая их изначальный c-код (если конечно правильно компилировал).

Для выполнения следующей инструкции используем команду **nexti**.

```bash
(gdb) nexti # выполнит текущую команду и перейдет к следующей, отобразив её в c-коде
(gdb) x/i $eip # не забывай, что можешь смотреть текущую инструкцию в ассемблере командой eximine/i
(gdb) x/3i $eip # или можешь посмотреть сразу 3 следующие инструкции
```



##### Программа

*firstprog.asm*

```assembly
push ebp #---------------------------0x08048374: Пролог программы
mov ebp, esp #-----------------------0x08048375: +
sub esp, 0x8 #-----------------------0x08048377: +
and esp, 0xfffffff0 #----------------0x0804837a: +
mov eax, 0x0 #-----------------------0x0804837d: +
sub esp, eax #-----------------------0x08048382: +
mov DWORD PTR [ebp-4], 0x0 #---------0x08048384: Реальный старт программы, обнуление переменной i
cmp DWORD PTR [ebp-4], 0x9 #---------0x0804838b: Цикл for
jle 0x08048393 #---------------------0x0804838f: переход на команду записи
jmp 0x080483a6 #---------------------0x08048391: выход из цикла
mov DWORD PTR [esp], 0x8048484 #-----0x08048393: Запись Hello world
call 0x80482a0 #---------------------0x0804839a: Вызов printf()
lea eax, [ebp-4] #-------------------0x0804839f: Готовимся к инкременту переменной i, записанной в ebp-4
inc DWORD PTR [eax] #----------------0x080483a2: Инкрементируем
jmp 0x804838b #----------------------0x080483a4: Возвращаемся в цикл
leave #------------------------------0x080483a6: Выход
ret #--------------------------------0x080483a7: Еще один
```

*firstprog.c*

```c
#include <stdio.h>

int main()
{
    int i;
    for(i=0; i < 10; i++)
    {
        printf("Hello world\n");
    }
    return 0;
}
```







### Назад к основам



##### Строки

*char_array.c* – [тупой код]

```c
#include <stdio.h>
int main()
{
    char str_a[20];
    str_a[0] = 'H';
    str_a[1] = 'e';
    str_a[2] = 'l';
    	/*...
    Hello world!\n
     	...*/
    str_a[11] = 'd';
    str_a[12] = '!';
    str_a[13] = '\n';
    str_a[14] = 0;
    /* учтем, что 0 - конец строки, а значит вывод будет только до этого символа */ 
    printf(str_a);
}
```

*char_array2.c* – [чуть более умный код]

```c
#include <stdio.h>
#include <string.h>
int main(){
    char str_a[20];
    strcpy(str_a, "Hello world!\n");
    printf(str_a);
}
```



Если поставить точку останова на функцию strcpy и в компиляторе вызвать *backtrace (bt)* можно посмотреть цепочку вызовов функций

```bash
(gdb) bt #отображает цепочку вызовов функций
```



##### Указатели

*pointer.c* – [тренинг указателей]

```c
#include <stdio.h>
#include <string.h>

int main(){
    char str_a[20];
    char *pointer;
    char *pointer2;
    
    strcpy(str_a, "Hello world!\n");
    pointer = str_a; //приравнивние ставит указатель на начало массива
    printf(pointer); //выведет "Hello world!"
    
    pointer2 = pointer + 2; //ставим его на два байта выше
    printf(pointer2); //выведет "llo world!"
    strcpy(pointer2, "y you guys!\n"); //запишет новый текст начиная с адреса pointer2
    printf(pointer); //выведет "Hey you guys!"   
}
```

```bash
# breakpoint на строке printf(pointer);
(gdb) x/xw pointer # так мы просим рассмотреть pointer как переменную и нас интересует лишь ее значение
# [0xbffff7e0] → 0x6c6c6548 (0x48(H) 0x65(e) 0x6c(l) 0x6c(l))
(gdb) x/xw &pointer # а так мы просим рассмотреть pointer как адрес и посмотреть что в нем
# [0xbffff7dc] → 0bffff7e0
```



Поподробнее

*addressof.c* – [про знак &]

```c
#include <stdio.h>

int main(){
    int int_var = 5;
    int *int_ptr;
    
    int_ptr = &int_var; 
    /* 
    в значение int_ptr помещается адрес int_var 
    но поскольку int_ptr используется в качестве указателя, 
    то мы все равно при необходимости будем работать со значением, просто добавляем абстракции
    */ 
}
```

В языке c есть два унарных оператора (&) и (\*). Не путай звездочку-(тип данных) при задании переменной и звездочку-(унарный оператор). Оператор (&) возвращает адрес переменной вместо ее значения. 

Оператор (\*) выполняет более сложную операцию. Он 

* <u>берет значение переменной</u>, 
* <u>переходит по адресу, хранящемуся в значении переменной</u>, 
* <u>возвращает значение, взятое по адресу</u>

Или если кратко – возвращает значение по адресу, хранящемуся в значении переданной переменной

```bash
# breakpoint на закрывающей скобке main, то есть в самом конце
(gdb) print int_var # просим вывести значение
# выведется "$1 = 5"
(gdb) print &int_var # просим вывести адрес
# выведется "$2 = (int *) 0xbffff804
(gdb) print int_ptr # просим вывести значение
# выведется $3 = (int *) 0xbffff804
(gdb) print &int_ptr # просим вывести адрес
# выведется $4 = (int **) 0xbffff800
# int ** значит, что мы выводим как бы адрес адреса

(gdb) print *int_ptr #просим перейти по адресу, хранящемуся в значении переменной и вывести значение уже этого адреса
# выведется $5 = 5
# как это работает
# int_ptr = 0xbffff804
# [0xbffff804] → 0xbffff800
# [0xbffff800] → 5
```



##### Форматирующие строки

Спецификаторы

| Спецификатор | Тип вывода                                                   | Тип данных |
| :----------- | ------------------------------------------------------------ | ---------- |
| %d           | Десятичный                                                   | Значение   |
| %u           | Десятичный без знака                                         | Значение   |
| %x           | Шестнадцатеричный                                            | Значение   |
| %s           | Строка (выводит символы от переданного адреса до 0-байта)    | Указатель  |
| %n           | Количество записанных байтов (<u>!! не считывает, а записывает</u>) | Указатель  |

*fmt_string.c* – [про форматирование]

```c
#include <stdio.h>

int main(){
    char string[10];
    int A = -73;
    unsigned int B = 31337;
    strcpy(string, "sample");

    printf("[A] Dec: %d, Hex: %x, Unsigned: %u\n", A, A, A);
    printf("[A] Address: %08x\n", &A);
    printf("[B] Dec: %d, Hex: %x, Unsigned: %u\n", B, B, B);
    printf("[ширина поля B] 3: '%3u', 10: '%10u', '%08u'\n", B, B, B);
    printf("[строка] %s адрес %08x\n", string, string);
    
}
```

В спецификаторе после процента, но перед буквой можно задать минимальную длину выводимой строки добавляемую пробелами слева от числа. Если длина задана с 0 в начале (08 например), то вместо пробелов число будет дополнено нулями.

*примечание: хочешь поравнять не слева, а справа - юзай **\t***

*input.c* – играемся с вводом

```c
#include <sdtio.h>
#include <string.h>

int main(){
    char message[10];
    int count, i;
    strcpy(message, "Hello, world!\n");
    printf("Сколько раз повторить");
    scanf("%d", &count);

    for(int i=0; i<count; i++){
        printf("%3d - %s\n", i, message);
    }
}
```

scanf("%d", &count) – считывает пользовательский ввод в указанном формате и записывает его по переданному адресу.



##### Приведение типов

Приведение типов производится как неявное приведение в c# – (новый тип) переменная

typecasting.c – [typecasting переводится как приведение типов]

```c
#include <stdio.h>

int main(){
    int a, b;
    float c, d;
    
    a = 13;
    b = 5;
    c = a / b;
    d = (float) a / (float) b;
    
    printf("[integers]\t a = %d\t b = %d\n", a, b);
    printf("[floats]\t c = %f\t d = %f\n", c, d)
    //выведет c = 2.000000 d = 2.600000
}
```





