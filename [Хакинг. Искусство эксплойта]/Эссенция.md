# Хакинг. Искусство эксплойта (Джон Эриксон)

Книга читается – хакинг изучается



### Начнем с малого

```bash
gcc firstprog.c # скомпилировать c-код в исполняемый файл a.out
gcc -o programm_name firstprog.c # скомпилировать c-код в исполняемый файл programm_name
ls -lh a.out
./a.out
```



##### Расширяем горизонты

```bash
# посмотреть дизассемблированный код a.out
objdump -D a.out | grep -A20 main.:

# посмотреть дизассемблированный код a.out в синтаксисе интел
objdump -M intel -D a.out | grep -A20 main.:
```



##### Работаем с отладчиком

```bash
gdb -q a.out
# дальше все что начинается с (gdb) происходит внутри отладчика
(gdb) break main # поставить точку останова на функции main
# (gdb) break 6 - поставить точку останова на 6 строке
(gdb) run # запустить прогу
(gdb) info registers # посмотреть состояние регистров до запуска мейна
(gdb) quit # выйти из отладчика
```



##### И вот они регистры x86 слева направо

| Название                       | Суть                                                         |
| :----------------------------- | ------------------------------------------------------------ |
| **Временные переменные**       | *=====================================================================* |
| **eax**                        | аккумулятор                                                  |
| **ecx**                        | счетчик                                                      |
| **edx**                        | данных                                                       |
| **ebx**                        | база                                                         |
| **Регистры общего назначения** | *=====================================================================* |
| **esp**                        | указатель стека                                              |
| **ebp**                        | указатель базы                                               |
| **esi**                        | индекс источника                                             |
| **edi**                        | индекс приемника                                             |
| **Особые**                     | *=====================================================================* |
| **eip**                        | указатель инструкции                                         |
| **eflags** (pf sf if)          | флаги для сравнений и адресации                              |



##### Настраиваем отладчик под Интел архитектуру

```bash
gdb -q
(gbd) set disassembly intel
(gdb) quit

echo "set dis intel" > ~/.gdbinit # 1) команды gdb можно сокращать 2) настройки нужно сохранить для перезапусков
```



##### Еще синтаксис компилятора и отладчика

```bash
gcc -g firstprog.c # добавляет в программу данные о коде
gdb -q a.out
(gdb) list # выведет c-код программы
(gdb) disassemble main # вывести дизассемблированный мейн (disass main)
(gdb) break main # поставить как обычно точку останова
(gdb) run # запустить прогу (теперь отладчик знает на какой строке c-кода он остановился)
(gdb) info register eip # (i r eip, если кратко) посмотреть что находится в регистре указателя инструкции
```



##### Исследование памяти

Для изучения памяти используется команда **examine** (кратко - **x**). 

Цифрой обозначается количество блоков для вывода.

Способы вывода блоков:

1) o – в виде восьмеричного числа
2) x – в виде шестнадцатеричного числа
3) u – в виде целого десятеричного числа без знака
4) d – в виде двоичного числа

Размер выводимого блока регулируется второй буквой (*помни про little-endian*)

1. b – байт
2. h – полуслово (2 байта) [ слово в ассемблере ]
3. w – слово (4 байта) [ DWORD в ассемблере ] **default**
4. g – гига-слово (8 байт)

```bash
(gdb) x/x 0x8048384 # вывести 4 байта ячейки 0x8048384 в шестнадцатиричном формате
(gdb) x/4ug 0x8048384 # вывести 4 раза по 8 байтов начиная с ячейки 0x8048384
(gdb) print $ebp - 4 # созранит в переменной $1 свое значение для дальнейшего использования
(gdb) x/dw $1 # вывести 4 байта в двоичном коде из ячейки (ebp-4) 
```

Особые случаи

1. i – вывести инструкцию из данной ячейки.
2. c – вывести при возможности ASCII символы
3. s – не заморачиваясь вывести просто ASCII строку, записанную начиная с заданной ячейки до ближайшего 0

```bash
(gdb) x/i 0x8048394 # инструкция по адресу
(gdb) x/6cb 0x8048484 # 12 символов по байтно (если не символ - вернет значение)
(gdb) x/s 0x8048484 # без изысков - просто выведет строку "Hello world!\n" например
```



##### Инструкции

В GDB можно по порядку выполнять инструкции при этом еще и отображая их изначальный c-код (если конечно правильно компилировал).

Для выполнения следующей инструкции используем команду **nexti**.

```bash
(gdb) nexti # выполнит текущую команду и перейдет к следующей, отобразив её в c-коде
(gdb) x/i $eip # не забывай, что можешь смотреть текущую инструкцию в ассемблере командой eximine/i
(gdb) x/3i $eip # или можешь посмотреть сразу 3 следующие инструкции
```



##### Программа

*firstprog.asm*

```assembly
push ebp #---------------------------0x08048374: Пролог программы
mov ebp, esp #-----------------------0x08048375: +
sub esp, 0x8 #-----------------------0x08048377: +
and esp, 0xfffffff0 #----------------0x0804837a: +
mov eax, 0x0 #-----------------------0x0804837d: +
sub esp, eax #-----------------------0x08048382: +
mov DWORD PTR [ebp-4], 0x0 #---------0x08048384: Реальный старт программы, обнуление переменной i
cmp DWORD PTR [ebp-4], 0x9 #---------0x0804838b: Цикл for
jle 0x08048393 #---------------------0x0804838f: переход на команду записи
jmp 0x080483a6 #---------------------0x08048391: выход из цикла
mov DWORD PTR [esp], 0x8048484 #-----0x08048393: Запись Hello world
call 0x80482a0 #---------------------0x0804839a: Вызов printf()
lea eax, [ebp-4] #-------------------0x0804839f: Готовимся к инкременту переменной i, записанной в ebp-4
inc DWORD PTR [eax] #----------------0x080483a2: Инкрементируем
jmp 0x804838b #----------------------0x080483a4: Возвращаемся в цикл
leave #------------------------------0x080483a6: Выход
ret #--------------------------------0x080483a7: Еще один
```

*firstprog.c*

```c
#include <stdio.h>

int main()
{
    int i;
    for(i=0; i < 10; i++)
    {
        printf("Hello world\n");
    }
    return 0;
}
```







### Назад к основам



##### Строки

*char_array.c* – [тупой код]

```c
#include <stdio.h>
int main()
{
    char str_a[20];
    str_a[0] = 'H';
    str_a[1] = 'e';
    str_a[2] = 'l';
    	/*...
    Hello world!\n
     	...*/
    str_a[11] = 'd';
    str_a[12] = '!';
    str_a[13] = '\n';
    str_a[14] = 0;
    /* учтем, что 0 - конец строки, а значит вывод будет только до этого символа */ 
    printf(str_a);
}
```

*char_array2.c* – [чуть более умный код]

```c
#include <stdio.h>
#include <string.h>
int main(){
    char str_a[20];
    strcpy(str_a, "Hello world!\n");
    printf(str_a);
}
```



Если поставить точку останова на функцию strcpy и в компиляторе вызвать *backtrace (bt)* можно посмотреть цепочку вызовов функций

```bash
(gdb) bt #отображает цепочку вызовов функций
```



##### Указатели

*pointer.c* – [тренинг указателей]

```c
#include <stdio.h>
#include <string.h>

int main(){
    char str_a[20];
    char *pointer;
    char *pointer2;
    
    strcpy(str_a, "Hello world!\n");
    pointer = str_a; //приравнивние ставит указатель на начало массива
    printf(pointer); //выведет "Hello world!"
    
    pointer2 = pointer + 2; //ставим его на два байта выше
    printf(pointer2); //выведет "llo world!"
    strcpy(pointer2, "y you guys!\n"); //запишет новый текст начиная с адреса pointer2
    printf(pointer); //выведет "Hey you guys!"   
}
```

```bash
# breakpoint на строке printf(pointer);
(gdb) x/xw pointer # так мы просим рассмотреть pointer как переменную и нас интересует лишь ее значение
# [0xbffff7e0] → 0x6c6c6548 (0x48(H) 0x65(e) 0x6c(l) 0x6c(l))
(gdb) x/xw &pointer # а так мы просим рассмотреть pointer как адрес и посмотреть что в нем
# [0xbffff7dc] → 0bffff7e0
```



Поподробнее

*addressof.c* – [про знак &]

```c
#include <stdio.h>

int main(){
    int int_var = 5;
    int *int_ptr;
    
    int_ptr = &int_var; 
    /* 
    в значение int_ptr помещается адрес int_var 
    но поскольку int_ptr используется в качестве указателя, 
    то мы все равно при необходимости будем работать со значением, просто добавляем абстракции
    */ 
}
```

В языке c есть два унарных оператора (&) и (\*). Не путай звездочку-(тип данных) при задании переменной и звездочку-(унарный оператор). Оператор (&) возвращает адрес переменной вместо ее значения. 

Оператор (\*) выполняет более сложную операцию. Он 

* <u>берет значение переменной</u>, 
* <u>переходит по адресу, хранящемуся в значении переменной</u>, 
* <u>возвращает значение, взятое по адресу</u>

Или если кратко – возвращает значение по адресу, хранящемуся в значении переданной переменной

```bash
# breakpoint на закрывающей скобке main, то есть в самом конце
(gdb) print int_var # просим вывести значение
# выведется "$1 = 5"
(gdb) print &int_var # просим вывести адрес
# выведется "$2 = (int *) 0xbffff804
(gdb) print int_ptr # просим вывести значение
# выведется $3 = (int *) 0xbffff804
(gdb) print &int_ptr # просим вывести адрес
# выведется $4 = (int **) 0xbffff800
# int ** значит, что мы выводим как бы адрес адреса

(gdb) print *int_ptr #просим перейти по адресу, хранящемуся в значении переменной и вывести значение уже этого адреса
# выведется $5 = 5
# как это работает
# int_ptr = 0xbffff804
# [0xbffff804] → 0xbffff800
# [0xbffff800] → 5
```



##### Форматирующие строки

Спецификаторы

| Спецификатор | Тип вывода                                                   | Тип данных |
| :----------- | ------------------------------------------------------------ | ---------- |
| %d           | Десятичный                                                   | Значение   |
| %u           | Десятичный без знака                                         | Значение   |
| %x           | Шестнадцатеричный                                            | Значение   |
| %s           | Строка (выводит символы от переданного адреса до 0-байта)    | Указатель  |
| %n           | Количество записанных байтов (<u>!! не считывает, а записывает</u>) | Указатель  |

*fmt_string.c* – [про форматирование]

```c
#include <stdio.h>

int main(){
    char string[10];
    int A = -73;
    unsigned int B = 31337;
    strcpy(string, "sample");

    printf("[A] Dec: %d, Hex: %x, Unsigned: %u\n", A, A, A);
    printf("[A] Address: %08x\n", &A);
    printf("[B] Dec: %d, Hex: %x, Unsigned: %u\n", B, B, B);
    printf("[ширина поля B] 3: '%3u', 10: '%10u', '%08u'\n", B, B, B);
    printf("[строка] %s адрес %08x\n", string, string);
    
}
```

В спецификаторе после процента, но перед буквой можно задать минимальную длину выводимой строки добавляемую пробелами слева от числа. Если длина задана с 0 в начале (08 например), то вместо пробелов число будет дополнено нулями.

*примечание: хочешь поравнять не слева, а справа - юзай **\t***

*input.c* – играемся с вводом

```c
#include <sdtio.h>
#include <string.h>

int main(){
    char message[10];
    int count, i;
    strcpy(message, "Hello, world!\n");
    printf("Сколько раз повторить");
    scanf("%d", &count);

    for(int i=0; i<count; i++){
        printf("%3d - %s\n", i, message);
    }
}
```

scanf("%d", &count) – считывает пользовательский ввод в указанном формате и записывает его по переданному адресу.



##### Приведение типов

Приведение типов производится как неявное приведение в c# – (новый тип) переменная

typecasting.c – [typecasting переводится как приведение типов]

```c
#include <stdio.h>

int main(){
    int a, b;
    float c, d;
    
    a = 13;
    b = 5;
    c = a / b;
    d = (float) a / (float) b;
    
    printf("[integers]\t a = %d\t b = %d\n", a, b);
    printf("[floats]\t c = %f\t d = %f\n", c, d)
    //выведет c = 2.000000 d = 2.600000
}
```

Приведение указателей - дело более нежное, но по факту заключается лишь в размере типа данных, на который указывает указатель.

*pointer_types3.c* – [предыдущие 2 смотри в папке]

```c
#include <stdio.h>

int main(){
    int i;
    char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
    int int_array[5] = {1, 2, 3, 4, 5};
    char *char_pointer;
    int *int_pointer;
    char_pointer = (char *) int_array; // здесь мы объясняем char_pointer что он все равно остается собой
    int_pointer = (int *) char_array;  // вне зависимости от того, на что он указывает

    for(i=0; i<5; i++){
        printf("[integer pointer] указывает на адрес %p, сожержащий целое число '%c'\n", int_pointer, *int_pointer);
        int_pointer = (int *) ((char *) int_pointer + 1); // прибавляем 1, так как к char pointer прибавляется 1
    }
    for(i=0; i<5; i++){
        printf("[char_pointer] указывает на адрес %p, содержащий символ %d\n", char_pointer, *char_pointer);
        char_pointer = (char *) ((int *) char_pointer + 1); // прибавляем 4, так как привели к int *
    }
}
```

Однако чтобы не изобретать велосипеды есть специальный "<u>пустой указатель</u>" void *. Этот тип может ссылаться на любой тип, но чтобы <u>разыменовать</u> его (вывести в форматированной строке) его нужно привести к нужному типу.

*pointer4.c* – [момент где все встает на свои места]

```c
#include <stdio.h>

int main(){
    int i;
    char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
    int int_array[5] = {1, 2, 3, 4, 5};
    void *void_pointer;
    void_pointer = (void *) char_array;
    
    for(i=0; i<5; i++){
        printf("[char pointer] указывает на адрес %p, сожержащий целое число '%c'\n", void_pointer, *((char *) void_pointer));
        void_pointer = (void *) ((char *) void_pointer + 1);
    }

    void_pointer = (void *) int_array;
    for(i=0; i<5; i++){
        printf("[integer pointer] указывает на адрес %p, содержащий символ %d\n", void_pointer, *((int *) void_pointer));
        void_pointer = (void *) ((int *) void_pointer + 1);
    }
}
```

 По факту приведение работает так, что в качестве пустого указателя можно использовать любой 4-байтный тип данных.

*pointer_types5.c* – [плохие вещи]

```c
#include <stdio.h>

int main(){

    int i;
    char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
    int int_array[5] = {1, 2, 3, 4, 5};
    unsigned int no_pointer;
    no_pointer = (unsigned int) char_array;
    
    for(i=0; i<5; i++){
        printf("[no_pointer] указывает на адрес %p, сожержащий целое число '%c'\n", no_pointer, *((char *) no_pointer));
        no_pointer = no_pointer + sizeof(char); // все проще!
    }

    no_pointer = (unsigned int) int_array;
    for(i=0; i<5; i++){
        printf("[no_pointer] указывает на адрес %p, содержащий символ %d\n", no_pointer, *((int *) no_pointer));
        no_pointer = no_pointer + sizeof(int);
    }

}
```

Подводя итоги, можно сказать – что в связке **[адрес] → значение** есть третий элемент **[адрес] → (тип данных) → значение**, определяющий взаимодействие со значением.



##### Аргументы командной строки

Доступ к аргументам осуществляется добавлением в main двух аргументов – main(int arg_count, char *arg_list[]). Первый – понятно, что является количеством аргументов. Второй же – массив строк. Именно строк, там лежат несколько указателей, каждый из которых ведет к строке, лежащей в памяти и заканчивающейся нулевым байтом.

*comandline.c* – [с аргументами, но без комментариев]

```c
#include <stdio.h>

int main(int arg_count, char *arg_list[]){
    int i;
    printf("Было предоставлено %d аргументов:\n", arg_count);
    for(i=0; i < arg_count; i++)
        printf("аргумент #%d\t-\t%s\n", i, arg_list[i]);
}
```

Нулевым аргументом является имя исполняемого двоичного файла. Остальные обычно называются вектором аргументов. Иногда bp-из-за этого arg_list[] называют на argv[].

Для прочтения численных аргументов используется функция **atoi()**, сокращенная от *ASCII to int*.

*convert2.c* – [уже сломанный]

```c
#include <stdio.h>
#include <stdlib.h> // сам добавил, так лучше вроде
void usage(char *program_name){
    printf("Usage: %s <message> <# of times to repeat>\n", program_name);
    exit(1);
}

int main(int argc, char *argv[]){
    int i, count;
    
    //if(argc < 3) usage(argv[0]); вызовем-ка ошибку сегментации

    count = atoi(argv[2]); // atoi = ASCII to int
    printf("Повторяем %d раза...\n", count);

    for(i=0; i<count; i++){
        printf("%3d - %s\n", i, argv[1]);
    }
}
```

Из-за закоменченого фрагмента можно словить ошибку сегментации при передаче одного аргумента

```bash
(gdb) where # комманда трассировки стека - поможет если что
```



##### Область видимости переменных

Видимость переменных в c очевидная. Глобальные переменные – те, которые объявлены в самом начале кода все какой-либо функции. Порядок объявления и вызова переменных важен!

Если поставить точку останова внутри вложенной функции и вызвать обратной трассировки стека, то можно посмотреть иерархию вызовов. Каждый вызов функции сохраняет текущую позицию в стековом кадре (stack frame). Его то мы и смотрим.

```bash
(gdb) bt # команда как where, только вроде как в обратную сторону
(gdb) bt full # еще и локальные переменные покажет
```

Еще есть статичные переменные (static int). Эти переменные сохраняют свое значение между двумя вызовами функции и не перезаписываются при объявлении в новом вызове функции. Они инициализируются один раз. А еще они ведут себя как локальные и могут существовать независимо в разных функциях. В полной трассировке стека отображаются. См. static.c!

Статические и глобальные переменные обычно занимают старшие адреса, по сравнению с локальными переменными. Или наоборот в зависимости от процессора.



##### Сегментация памяти

Память делится на 5 разделов (сегментов).

| Код (text) | Инициализированные данные (data) | Неинициализированные данные (bss) | Куча (heap) | Стек (stack) |
| ---------- | -------------------------------- | --------------------------------- | ----------- | ------------ |

**Сегмент кода**

Процесс работы с сегментом кода следующий:

1) читается команда по адресу, лежащему в значении **eip**;
2) регистр **eip** увеличивается на размер команды в байтах;
3) выполняется команда;

<u>В сегмент кода запись запрещена</u>! Благодаря этому можно запускать несколько версий программы, но нельзя на горячую изменять код. 

*Размер фиксирован.*



**Сегменты инициализированных (data) и неинициализированных (bss) данных**

Здесь хранятся глобальные и статические переменные. Если при объявлении переменной ей присвоили значение, то она попадает в data, если нет – в bss

*Размер фиксирован.*



**Сегмент кучи**

Этим сегментом можно управлять вручную (malloc). Представляет собой зарезервированную память. Ей можно пользоваться для хранения любых данных.

*Растет в направлении старших адресов. Размер не фиксирован.*



**Сегмент стека**

Временное хранилище локальных переменных и контекстов функций. В отладчике отображается командой bt. *Стековый кадр* – набор локальных переменных от одного контекста до другого. Стек работает по принципу *FILO*. Помещение в стек называется *проталкиванием (pushing)*, извлечение из стека – *выталкиванием (popping)*.

Адрес вершины стека хранится в регистре **esp**. Регистр **ebp** называется указателем кадра – frame pointer (FP) или указателем локальной базы – local base (LB). 

В каждом кадре стека хранится переданные в функцию параметры, локальные переменные, и два указателя (SFP - saved frame pointer - сохраненный указатель кадра - предыдущее значение **ebp**) и (адрес возврата - предыдущее значение **eip**).

*Растет в направлении младших адресов. Размер не фиксирован.*

*stack_exemple.c* – [первая кровь]

```c
#include <stdio.h>
void test_function(int a, int b, int c, int d){
    int flag;
    char buffer[10];

    flag = 31337;
    buffer[0] = 'A';
}

int main(){
    test_function(1, 2, 3, 4);
}
```

*stack_exemple.ASM* – [мы снова встретились]

```assembly
# ============main=============================
push ebp #--------------------------0x08048357: Формирование стекового кадра (пролог), сохранение предыдущего ebp (SFP)
mov ebp, esp #----------------------0x08048358: Перемещение указателя на текущий кадр
sub esp, 0x18 #---------------------0x0804835a: 0x18 = 24 - Выделение размера кадра
and esp, 0xfffffff0 #---------------0x0804835d: 0 идей
mov eax, 0x0 #----------------------0x08048360:
sub esp, eax #----------------------0x08048365: Конец формирования стекового кадра
mov DWORD PTR [esp+12], 0x4 #-------0x08048367: Начало программы, помещение в стек аргументов в обратном порядке
mov DWORD PTR [esp+8], 0x3 #--------0x0804836f:
mov DWORD PTR [esp+4], 0x2 #--------0x08048377:
mov DWORD PTR [esp], 0x1 #----------0x0804837f:
call 0x8048344 #--------------------0x08048386: <test_function>
leave #-----------------------------0x0804838b: Это адрес возврата будет в вызове test_function
ret #-------------------------------0x0804838c:


# ============test_function====================
push ebp #--------------------------0x08048344: Пролог
mov ebp, esp #----------------------0x08048345:
sub esp, 0x28 #---------------------0x08048347: Конец пролога, 0x28 = 40
mov DWORD PTR [ebp-12], 0x7a69 #----0x0804834a: Начало программы, 0x7a69 = 31337
mov BYTE PTR [ebp-40], 0x41 #-------0x08048351: 0x41 = 65
leave #-----------------------------0x08048355:
ret #-------------------------------0x08048356:

```



**|	Непонятный Стек функции test_function**

|                                    | Верх стека                  |                          |
| ---------------------------------- | --------------------------- | ------------------------ |
| Младшие адреса                     |                             |                          |
| (0xbffff7c0) **Текущий esp**       | Массив buffer (10 символов) | 28 байтов [ebp-40]       |
| (0xbffff7dc)                       | Переменная flag             | 4 байта [ebp-12]         |
| (0xbffff7e0)                       |                             | 4 пропащих байтов??      |
| (0xbffff7e4)                       |                             | еще 4 пропащих байта     |
| (0xbffff7e8)  (Текущий ebp???????) | SPF (предыдущий ebp)        | 4 байта                  |
| (0xbffff7ec)                       | ret (адрес возврата)        | 4 байта                  |
| (0xbffff7f0) **Старый esp**        | a                           | 4 байта [esp старый]     |
| (0xbffff7f4)                       | b                           | 4 байта [esp старый +4]  |
| (0xbffff7f8)                       | c                           | 4 байта [esp старый +8]  |
| (0xbffff7fc)                       | d                           | 4 байта [esp старый +12] |
| +++                                | +++                         | +++ 12 байт              |
| (0xbffff808) **Старый ebp**        | Дно стека                   | [esp старый + 24]        |
| Старшие адреса                     |                             |                          |





**|	Моя понятная попытка номер 2** (компилировал в облаке Яндекса на Intel Ice Lake)

|                            | Верх стека                  |                        |
| -------------------------- | --------------------------- | ---------------------- |
| Младшие                    |                             |                        |
| 0x7fffffffe430: rspX (rbp) | ecx (d) = 0x4 (4)           | rbp - 0x30 (4 байта)   |
| 0x7fffffffe434             | edx (c) = 0x3 (3)           | rbp - 0x2c (4 байта)   |
| 0x7fffffffe438             | esi (b) = 0x2 (2)           | rbp - 0x28 (4 байта)   |
| 0x7fffffffe43c             | edi (a) = 0x1 (1)           | rbp - 0x24 (4 байта)   |
| 0x7fffffffe440             | *мусор какой-то*            | rbp - 0x20 (4 байта)   |
| 0x7fffffffe444             | *мусор какой-то*            | rbp - 0x1c (4 байта)   |
| 0x7fffffffe448             | flag = 0x7a69               | rbp - 0x18 (4 байта)   |
| 0x7fffffffe44e             | buffer = 0x41 ++0x00        | rbp - 0x12 (10 байтов) |
| 0x7fffffffe450             | 0x00000000                  | rbp - 0x10 ++          |
| 0x7fffffffe454             | 0x00000000                  | rbp - 0xc ++           |
| 0x7fffffffe458             | *мусор какой-то*            | rbp - 0x8 (4 байта)    |
| 0x7fffffffe45c             | *мусор какой-то*            | rbp - 0x4 (4 байта)    |
| 0x7fffffffe460: rbpX (ebp) | предыдущий rbp вторая часть | rbp (8 байтов)         |
| 0x7fffffffe464             | предыдущий rbp первая часть |                        |
| 0x7fffffffe468 rsp1        | SFP вторая часть            | 8 байтов               |
| 0x7fffffffe46c             | SFP первая часть            |                        |
| 0x7fffffffe470 rbp1        |                             |                        |
| Старшие                    |                             |                        |



##### Сегменты памяти в языке C

**|	memory_segments.c**

```c
#include <stdio.h>

int global_var;
int global_initialized_var = 5;

void function(){
    int stack_var;
    printf("0x%08x: stack_var (function)\n", &stack_var);
}

int main(){
    int stack_var;
    int stack_var2 = 5;
    static int static_initialized_var = 5;
    static int static_var;
    int *heap_var_ptr;

    heap_var_ptr = (int *)malloc(4); // malloc возвращает void*
	//-------------------------------------------------------------------: каждый раз по разному
   	//-------------------------------------------------------------------: но хоть что-то
    printf("0x%08x: global_initialized_var\n", &global_initialized_var); //-----:0x442c4010
    printf("0x%08x: static_initialized_var\n", &static_initialized_var); //-----:0x442c4014
    printf("0x%08x: global_var\n", &global_var); //-----------------------------:0x442c401c
    printf("0x%08x: static_var\n", &static_var); //-----------------------------:0x442c4020
    printf("0x%08x: heap_var_ptr\n", heap_var_ptr); //--------------------------:0x456ac2a0
    printf("0x%08x: stack_var\n", stack_var); //--------------------------------:0x00007ffe
    printf("0x%08x: stack_var2\n", stack_var2); //------------------------------:0x00000005
    function(); //--------------------------------------------------------------:0x1b6dd924

}
```

Что я могу наверняка сказать по этому поводу наверняка: BSS и DATA занимают немного памяти и находятся на небольшом расстоянии. HEAP прилегает к ним и растет от них. STACK – до сих пор для меня женщина-загадка. Где находится TEXT – узнаем в следующих сериях.



##### Работа с кучей

**|	heap_example.c**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(){
    char *char_ptr;
    int *int_ptr;
    int mem_size;

    if(argc<2) mem_size = 50;
    else mem_size = atoi(argv[1]); // atoi = ascii to int

    // ================================! 1 итерация !================================
    printf("===! act 1 !===\n");
    printf("\t[+] выделяется %d байтов в куче для char_ptr\n", mem_size);
    char_ptr = (char *) malloc(mem_size);

    if(char_ptr == NULL){
        fprintf(stderr, "Ошибка: невозможно выделить память в куче!\n");
        exit(-1);
    }

    strcpy(char_ptr, "Эта память находится в куче.\n"); // 29 символов = 23*2+6=53 байта?
    printf("char_ptr (%p) → %s\n" char_ptr, char_ptr); // %s тоже съедает указатель
    
    // ================================! 2 итерация !================================
    printf("===! act 2 !===\n");
    printf("\t[+] выделяется 12 байтов в куче для переменной int_ptr\n");
    int_ptr = (int *) malloc(12);

    if(int_ptr == NULL){
        fprintf(stderr, "Ошибка: невозможно выделить память в куче!\n");
        exit(-1);
    }

    *int_ptr = 31337; //  0x7A69
    printf("int_ptr (%p) → %d\n", int_ptr, *int_ptr); // для %d уже нужен оператор (*)

    // ================================! 3 итерация !================================
    printf("===! act 3 !===\n");
    printf("\t[-] освобождается память, занятая char_ptr\n");
    free(char_ptr);

    // ================================! 4 итерация !================================
    printf("===! act 4 !===\n");
    printf("\t[+] выделяется еще 15 байтов для переменной char_ptr\n");
    char_ptr = (char *)malloc(15);

    if(char_ptr == NULL){
        fprintf(stderr, "Ошибка: невозможно выделить память в куче!\n");
        exit(-1);
    }

    strcpy(char_ptr, "новая память"); // 12 символов = 11*2+1=23 байта?
    printf("char_ptr (%p) → %s\n" char_ptr, char_ptr);

    // ================================! 5 итерация !================================
    printf("===! act 5 !===\n");
    printf("\t[-] освобождается память, занятая int_ptr\n");
    free(int_ptr);
    printf("\t[-] освобождается память, занятая char_ptr\n");
    free(char_ptr);
}
```

**|	heap memory**

| HEX (50 \|\| 41)                | HEX (60)                        | HEX (100)                      | VAR                      |
| ------------------------------- | ------------------------------- | ------------------------------ | ------------------------ |
| 0x55ad9a02e**6b0** *(1712) +0*  | 0x55de96035**6b0** *(1712) +0*  | 0x55de96035**6b0** *(1712) +0* | char_ptr 1 итерация      |
| 0x55ad9a02e**6f0** *(1776) +64* | 0x55de96035**700** *(1792) +80* | 0x55de96035**720** (1824) +112 | int_ptr 2 итерация (12)  |
| 0x55ad9a02e**710** *(1808) +32* | 0x55de96035**720** (1824) +32   | 0x55de96035**740** (1856) +32  | char_ptr 4 итерация (15) |

*Примечание:* У меня начинает крашиться на аргументе равном 40.

*Примечание 2:* При зачитке 100 байтов по идее 4 итерация должна была начать с начала. Но у меня не сработало.



##### Malloc с контролем ошибок

```c
void *error_checked_malloc(unsigned int); // Прототип функции ?????????

// место для main из предыдущей функции

void *error_checked_malloc(unsigned int size){
    void *ptr;
    ptr = malloc(size);
    if(ptr == NULL){
        fprintf(stderr, "Ошибка, невозможно выделить память в куче.\n");
        exit(-1);
    }
    returt ptr;
}
```



### Дополнения к основам

##### Доступ к файлам

Есть 2 способа: <u>Файловые дескрипторы</u> и <u>Файловые потоки</u>

Файловые дексрипторы (низкоуровневые) – труъ вайлд функции для и/о;

Файловые потоки (высокоуровневые) – буфферизировано-карамелизированная оболочка для первых;

**Поговорим о декрипторах**

Файловый дескриптор – это уникальное для каждого файла число, его характеризующее. (Как штрихкод? или инвентарник).

```c
open(); // Возвращает дескриптор, Аргументы: указатель на имя файла, набор флагов доступа
close(); // Забирает дескриптор в качестве аргумента
read(); // Аргументы: дескриптор, указатель, количество байтов
write();
```

В случае ошибки каждая из них вернет -1.

Остальное - в базе c.



##### Идентификаторы пользователей





