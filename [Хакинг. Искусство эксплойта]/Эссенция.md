# Хакинг. Искусство эксплойта (Джон Эриксон)

Книга читается – хакинг изучается



###### Начнем с малого

```bash
gcc firstprog.c #скомпилировать c код в исполняемый файл a.out
ls -lh a.out
./a.out
```



###### Расширяем горизонты

```bash
#посмотреть дизассемблированный код a.out
objdump -D a.out | grep -A20 main.:

#посмотреть дизассемблированный код a.out в синтаксисе интел
objdump -M intel -D a.out | grep -A20 main.:
```



###### Работаем с отладчиком

```bash
gdb -q a.out
#дальше все что начинается с (gdb) происходит внутри отладчика
(gdb) break main #поставить точку останова
(gdb) run #запустить прогу
(gdb) info registers #посмотреть состояние регистров до запуска мейна
(gdb) quit #выйти из отладчика
```



###### И вот они регистры x86 слева направо

| Название                       | Суть                                                         |
| :----------------------------- | ------------------------------------------------------------ |
| **Временные переменные**       | *=====================================================================* |
| **eax**                        | аккумулятор                                                  |
| **ecx**                        | счетчик                                                      |
| **edx**                        | данных                                                       |
| **ebx**                        | база                                                         |
| **Регистры общего назначения** | *=====================================================================* |
| **esp**                        | указатель стека                                              |
| **ebp**                        | указатель базы                                               |
| **esi**                        | индекс источника                                             |
| **edi**                        | индекс приемника                                             |
| **Особые**                     | *=====================================================================* |
| **eip**                        | указатель инструкции                                         |
| **eflags** (pf sf if)          | флаги для сравнений и адресации                              |



###### Настраиваем отладчик под Интел архитектуру

```bash
gdb -q
(gbd) set disassembly intel
(gdb) quit

echo "set dis intel" > ~/.gdbinit #1) команды gdb можно сокращать 2) настройки нужно сохранить для перезапусков
```



###### Еще синтаксис компилятора и отладчика

```bash
gcc -g firstprog.c #добавляет в программу данные о коде
gdb -q a.out
(gdb) list #выведет c-код программы
(gdb) disassemble main #вывести дизассемблированный мейн
(gdb) break main #поставить как обычно точку останова
(gdb) run #запустить прогу (теперь отладчик знает на какой строке c-кода он остановился)
(gdb) info register eip # (i r eip, если кратко) посмотреть что находится в регистре указателя инструкции
```



###### Исследование памяти

Для изучения памяти используется команда **examine** (кратко - **x**). 

Цифрой обозначается количество блоков для вывода.

Способы вывода блоков:

1) o – в виде восьмеричного числа
2) x – в виде шестнадцатеричного числа
3) u – в виде целого десятеричного числа без знака
4) d – в виде двоичного числа

Размер выводимого блока регулируется второй буквой (*помни про little-endian*)

1. b – байт
2. h – полуслово (2 байта) [ слово в ассемблере ]
3. w – слово (4 байта) [ DWORD в ассемблере ] **default**
4. g – гига-слово (8 байт)

```bash
(gdb) x/x 0x8048384 #вывести 4 байта ячейки 0x8048384 в шестнадцатиричном формате
(gdb) x/4ug 0x8048384 #вывести 4 раза по 8 байтов начиная с ячейки 0x8048384
(gdb) print $ebp - 4 #созранит в переменной $1 свое значение для дальнейшего использования
(gdb) x/dw $1 #вывести 4 байта в двоичном коде из ячейки (ebp-4) 
```

Особые случаи

1. i – вывести инструкцию из данной ячейки.
2. c – вывести при возможности ASCII символы
3. s – не заморачиваясь вывести просто ASCII строку, записанную начиная с заданной ячейки до ближайшего 0

```bash
(gdb) x/i 0x8048394 #инструкция по адресу
(gdb) x/6cb 0x8048484 #12 символов по байтно (если не символ - вернет значение)
(gdb) x/s 0x8048484 #без изысков - просто выведет строку "Hello world!\n" например
```



###### Инструкции

В GDB можно по порядку выполнять инструкции при этом еще и отображая их изначальный c-код (если конечно правильно компилировал).

Для выполнения следующей инструкции используем команду **nexti**.

```bash
(gdb) nexti #выполнит текущую команду и перейдет к следующей, отобразив её в c-коде
(gdb) x/i $eip #не забывай, что можешь смотреть текущую инструкцию в ассемблере командой eximine/i
(gdb) x/3i $eip #или можешь посмотреть сразу 3 следующие инструкции
```



###### firstprog ASM

```assembly
push ebp #---------------------------0x08048374: Пролог программы
mov ebp, esp #-----------------------0x08048375: +
sub esp, 0x8 #-----------------------0x08048377: +
and esp, 0xfffffff0 #----------------0x0804837a: +
mov eax, 0x0 #-----------------------0x0804837d: +
sub esp, eax #-----------------------0x08048382: +
mov DWORD PTR [ebp-4], 0x0 #---------0x08048384: Реальный старт программы, обнуление переменной i
cmp DWORD PTR [ebp-4], 0x9 #---------0x0804838b: Цикл for
jle 0x08048393 #---------------------0x0804838f: переход на команду записи
jmp 0x080483a6 #---------------------0x08048391: выход из цикла
mov DWORD PTR [esp], 0x8048484 #-----0x08048393: Запись Hello world
call 0x80482a0 #---------------------0x0804839a: Вызов printf()
lea eax, [ebp-4] #-------------------0x0804839f: Готовимся к инкременту переменной i, записанной в ebp-4
inc DWORD PTR [eax] #----------------0x080483a2: Инкрементируем
jmp 0x804838b #----------------------0x080483a4: Возвращаемся в цикл
leave #------------------------------0x080483a6: Выход
ret #--------------------------------0x080483a7: Еще один
```



###### firstprog.c

```c
#include <stdio.h>

int main()
{
    int i;
    for(i=0; i < 10; i++)
    {
        printf("Hello world\n");
    }
}
```







