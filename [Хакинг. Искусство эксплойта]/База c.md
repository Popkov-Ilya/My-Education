## База c

#### Базовые типы

| Тип           | Количество байтов |
| ------------- | ----------------- |
| int           | 4                 |
| insigned int  | 4                 |
| short int     | 2                 |
| long int      | 4                 |
| long long int | 8                 |
| float         | 4                 |
| char          | 1                 |
| pointer       | 4                 |


#### Указатели

Для экономии ресурсов большие участки памяти не перемещаются, и при необходимости в переменную просто записывается адрес начала нужного участка. Перед именем переменной с типом данных, хранящихся в памяти во время задания переменной указателя оставляют знак звездочки (*) – указатель.

```c
char *pointer; // задание указателя
strcpy(str_a, "Hello world!\n");
pointer = str_a; //приравнивние ставит указатель на начало массива
```

Для того, чтобы посмотреть адрес, а не значение указателя используется знак (&) перед переменной во время вызова.

*В языке c есть два унарных оператора (&) и (\*).  Оператор (&) возвращает адрес переменной вместо ее значения. Оператор (\*) возвращает значение по адресу, хранящемуся в значении переданной переменной. Вызов переменной без операторов вернет значение по адресу самой переменной.*

**&field** [Адрес переменной] → **field** [Значение переменной] → ***field** [Значение по указанному адресу]

Передача указателя в форматирующую строку называется <u>разыменованием</u>.

#### Форматирующие строки

Спецификаторы

| Спецификатор | Тип вывода                                                   | Тип данных |
| :----------- | ------------------------------------------------------------ | ---------- |
| %d           | Десятичный                                                   | Значение   |
| %u           | Десятичный без знака                                         | Значение   |
| %f           | С плавающей точкой                                           | Значение   |
| %x           | Шестнадцатеричный                                            | Значение   |
| %p           | Адрес в значении указателя                                   | Указатель  |
| %s           | Строка (выводит символы от переданного адреса до 0-байта)    | Указатель  |
| %c           | Символ по адресу.                                            | Указатель  |
| %n           | Количество записанных байтов (<u>!! не считывает, а записывает</u>) | Указатель  |



#### Работа с файлами

**|	Функции файлового дескриптора**

| Функция | Аргументы                                          | Что делаешь?                |
| ------- | -------------------------------------------------- | --------------------------- |
| open    | указатель на имя файла, набор флагов доступа       | Возвращает дескриптор (int) |
| close   | дескриптор                                         | Просто закрывает)           |
| read    | дескриптор, указатель на буффер, количество байтов |                             |
| write   | дескриптор, указатель на буффер, количество байтов |                             |

**|	Набор флагов fcntl.h (file control)**

| ФЛАГ     | Значение                                               |
| -------- | ------------------------------------------------------ |
| O_RDONLY | Только чтение                                          |
| O_WRONLY | Только запись                                          |
| O_RDWR   | И то и другое                                          |
| ====     | ====                                                   |
| O_APPEND | Докидывает в конец                                     |
| O_TRUNK  | Если файл уже существует – сокращает его длину до 0??? |
| O_CREAT  | (без E) создает файл, если его не существует           |





#### Функции разные

**|	ATOI**

```c
int i;
i = atoi(argv[1]); // конвертирует строковый ввод в целое число (приведение типов не так сработает)
```

**|	MALLOC × FREE**

```c
int *ptr; // -------------------------------------→ учти, что malloc возвращает только (void *)
ptr = (int *) malloc(20); // ---------------------→ выделить 20 байтов в куче и указать на них с помощью указателя ptr
*ptr = 12345; // ---------------------------------→ значения помещаются через оператор (*)
printf("int_ptr (%p) → %d\n", ptr, *int_ptr); // -→ посмотреть что там находится
free(ptr); // ------------------------------------→ освободить эти 20 байтов
```

**|	FPRINTF**

```c
fprintf(stderr, "Usage: %s <name>\n", argv[0]); // смотри как красиво можно делать
```

**| NULL**

```c
if(some_var == NULL) printf("some_var is null"); // NULL всегда пишется капсом
```

**|	Прототип функции**

```c
void *my_malloc(unsigned int); // объявляем Прототип функции

// используем прототип

void *my_malloc(unsigned int size){ // реализуем протитип
    returt malloc(size);
}
```

**|	Объявление указателей**

```c
char *buffer, *data_file; // можно объявлять по несколько штук. Но звезда у каждого своя. Поэтомц то там нет пробела
```

**|	Добавление новой строки**

```c
strncat(buffer_ptr, "\n", 1) // так вроде это делается
```

**|	STRLEN × Длина строки**

```c
write(fd, buffer, strlen(buffer)) // strlen находит длину строки. полезно при работе с буфером (char *)
```

**| PERROR**

```c
// Дополнительное сообщение об ошибке
prerror(message); // message (char *)
```

