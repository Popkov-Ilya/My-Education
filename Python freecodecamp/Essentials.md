

# Essentials

Сурс – https://youtu.be/rfscVS0vtbw



### Переменные

Вот здесь уже интересно.  Чтобы объявить переменную в питоне не нужно вообще ничего лишнего. Только имя переменной и значение. И ВСЕ!

```python
character_name = "John"
```



### Распространенные возможности

##### len(str)

```python
phrase = "some string"
int_var = len(phrase)
```

##### str(var)

```python
int_var = 5
print("xxx" + str(int_var))
```

##### int(var)

```python
int_var = int(str_var) // если передать число с точкой, питон не сможет
```

##### float(var)

```python
float_var = float(str_var)
```

##### input(str)

```python
name = input("enter your name: ") # переноса строки не будет
```

##### #formatted output

```python
var = 5
print(f"Formatted output the var = {var}") # нужно просто добавить букву  f перед кавычками
```

##### #math

```python
from math import *
```

```python
abs(int_var) # модуль
max(4, 6) # max | min
floor(3.7) # floor | cail
ceil(3.7)
print(round(112.5890, 3)) # выведет 112.59, потому что 0 параметр - это целое число

# примечание ===========================
print(round(112.5890, -1)) # выведет 110
# конец примечания =====================

pow(2, int_var) # 2^int_var

# примечание ==========================================
print(pow(2, 3000)) # работает!
# более того. 
# Если math импортирован, то значение выведется с e+xxx
# а если не интегрирован, то значение выедется целиком
# конец примечания ====================================

sqrt(36) # квадратный корень, очевидно
```



---

##### Индекс символа

```python
phrase = "some string"
STRING_var = phrase[0] # индекс все равно возвращает string
# заметка = отрицательные индексы здесь работают как надо
```



---

##### .index(str)

```python
phrase = "some string"
int_var = phrase.index("str") # вернет 5
```

##### .replace(str, str)

```python
phrase = "some string"
str_var = phrase.replace("some", "another")
```



### Списки

В питоне не заморачиваются, я так смотрю, с массивами и сразу юзают списки

```python
list_name = ["first", 7, True]
print(list_var[1] + list_var[-1]) # выведет 9 (отрицательные индесы работают)
print(list_var[1:]) # выведет массив с 1 элемента по последний
```

Списки – ссылочные типы. Если их приравнять, то изменения отразятся в обоих списках. Для копирования есть метод copy.

##### .extend(list_var)

Добавляет список в конец списка.

##### .append(var)

Добавляет элемент.

##### .insert(index, var)

Сначала индекс, потом значение.

##### .remove(var)

Удаляет по значению. По индексу смотри ниже. Без аргумента не работает. <u>Если передать несуществующее значение – вызовет ошибку.</u>

##### .pop(index)

Удаляет по индексу (даже отрицательному), так еще и значение возвращает. Золото, а не функция

Поп без аргумента удаляет последний (Очевидно).

##### .clear()

Очищает природу.

##### .index(var, start, stop)

Находит первое значение. Var обязательный, start и stop – нет. <u>Индекс от несуществующего вызовет ошибку.</u>

Потому что здесь минус 1 – последний элемент и возвращать его нельзя. А если ты хочешь проверить наличие – используй буквально count. Ну или contains если ты крутой.

##### .count(var)

Количество

##### .\__contains__(var)

Проверяет наличие.

##### .sort() | .reverse()

Очевидно

##### .copy()

Возвращает копию массива



### Заметки

*В конце проги должна оставаться пустая строка.*

*Если в принт запихнуть деление целых чисел, то он все равно выведет float*

*False = 0, True = 1, bool(3) = True*

*print может выводить массивы*
